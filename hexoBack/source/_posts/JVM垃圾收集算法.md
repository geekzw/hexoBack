---
title: JVM垃圾收集算法
date: 2016-11-09 11:08:30
categories: JVM
tags:
description: "标记清除算法是最基础的算法，算法分为标记和清除两个阶段：首先是标记出所有需要回收的对象，在标记完成后统一回收。"
---
标记清除算法是最基础的算法，算法分为标记和清除两个阶段：首先是标记出所有需要回收的对象，在标记完成后统一回收。
<!-- more -->
## 标记-清除
标记清除算法是最基础的算法，算法分为标记和清除两个阶段：首先是标记出所有需要回收的对象，在标记完成后统一回收。
标记过程：从GC Roots（虚拟机栈中引用的对象，方法区中类的静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）开始进行可达性分析，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用，需要被回收
清除过程：在标记过程后，所有需要回收的对象都已经被标记，此时就找到标记的对象进行垃圾回收
缺点：效率问题，标记和清除过程效率都不高；空间问题，标记清除后会产生大量的内存碎片，空间碎片化，导致后来的大对象无法找到足够大的连续内存而不得不触发另一次垃圾回收。
## 复制算法
复制算法是在标记清除的基础上，试图解决空间碎片化的问题，它把内存空间分成大小相等的两块，每次只使用其中的一块，当一块用完的时候，对这块进行标记，活的对象转移到另一块内存，然后把当前的内存直接清理掉
优点：解决了内存碎片化，分配内存只需要移动堆顶指针，顺序分配，效率高
缺点：显而易见，空间利用率低，每次只能使用一般内存，当对象存活率高时，每次要复制大量的对象，效率低
## 标记-整理算法
针对复制算法空间利用率低的缺点。标记整理的做法是：标记过程还是标记清除算法的逻辑，标记过后，不是直接回收对象，而是让对象向内存一端移动，然后再清理掉边界以外的内存

当前商业虚拟机的垃圾收集都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块，一般是把ava堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。在新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法回收。
在新生代中，因为98%的对象都是“朝生夕死”，所以把新生代堆分为一个较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，讲Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。HotSpot虚拟机默认Eden和Survivor大小比例8：1.
