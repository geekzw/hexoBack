---
title: 设计模式之观察者模式
date: 2017-09-13 14:20:08
tags: designMode
---
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
<!-- more -->

# 观察者模式定义
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己


----------
这个模式作为程序员应该都很熟悉，不用特意去举一些形象的例子。这个模式的实现思想也很简单。
# 观察者模式结构
先上一张盗来的图
![观察者模式结构图][1]
涉及角色

 - 抽象主题
 - 具体主题
 - 抽象观察者
 - 具体观察者
 


----------
下面就按照上述结构通过源码实现
# 观察者模式源码
### 抽象主题
![抽象主题][2]
### 具体主题
![具体主题][3]
### 抽象观察者
![此处输入图片的描述][4]
### 具体观察者
![具体观察者][5]


----------
以上就是简易观察者模式的完整代码，很简单，看着代码也很容易理解观察者模式的思想。需要说明的是，上述的实现方式是观察者模式中的**推**模式，意思就是当数据变化时，被观察者把数据全部推送给所有的观察者。当然，有推就有**拉**。**拉**模式的思想是。当数据变化时，被观察者只告诉所有观察者，我的数据变化了，或者只传给观察者少量参数，需要更多的话，自己去拉。下面我们实现以下拉的方式。
### 抽象主题
![抽象主题][6]
### 具体主题
![具体主题][7]
### 抽象观察者
![抽象观察者][8]
### 具体观察者
![具体观察者][9]


----------
两种方式的选择，要放到具体的场景，肯定是各有优势的。最后需要注意的是，千万不要忘记注销订阅，不然很容易内存泄漏，此次保存观察者用的是vector而不是list事因为vector是线程安全的。

  [1]: http://7xslom.com1.z0.glb.clouddn.com/image/7630FFE8-4302-4369-BE3D-200FC35FFA33.png
  [2]: http://7xslom.com1.z0.glb.clouddn.com/image/825E1FF8-D17E-4AE7-80BE-A96FFC971F86.png
  [3]: http://7xslom.com1.z0.glb.clouddn.com/image/CC0E72AE-3643-4B3A-A851-F3F38B3F8B6B.png
  [4]: http://7xslom.com1.z0.glb.clouddn.com/image/90287D5D-17F4-4282-B9EC-2DA9F2BA20A0.png
  [5]: http://7xslom.com1.z0.glb.clouddn.com/image/5D192E46-1A6A-4FB4-B834-E2B866D077E2.png
  [6]: http://7xslom.com1.z0.glb.clouddn.com/image/2BD33660-8A83-4542-9D10-824F1FEA3168.png
  [7]: http://7xslom.com1.z0.glb.clouddn.com/image/07C5E91E-96AA-4273-9A11-807C1BDD9E16.png
  [8]: http://7xslom.com1.z0.glb.clouddn.com/image/A90327D5-6547-4386-94A3-98FCAB372F5F.png
  [9]: http://7xslom.com1.z0.glb.clouddn.com/image/525BE41F-65CF-41F9-A159-CE3DE9B0524F.png
