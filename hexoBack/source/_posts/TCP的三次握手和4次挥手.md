---
title: TCP的三次握手和4次挥手
date: 2016-12-11 16:37:34
categories: net
tags: net
description: "TCP连接的建立和释放，都要经过复杂的过程，用来保证连接的可靠性。连接的时候采用三次握手模式，断开的时候采用四次挥手模式"
---
TCP连接的建立和释放，都要经过复杂的过程，用来保证连接的可靠性。连接的时候采用三次握手模式，断开的时候采用四次挥手模式
<!-- more -->
## TCP连接的建立
![三次握手][1]
TCP连接采用的是客户服务器形式，主动发起连接的是客户机，被动打开连接的是服务器。客户端和服务器在打开后，都会创建一个TCB块（里面存储着一些重要信息，TCp链接表，发送缓存指针等）。然后客户端可以向服务端发送数据，服务端等待接收。
* A首先向B发送连接报文，首部中的SYN = 1，序号为seq = x。TCP规定，SYN报文段不能携带数据，但是要消耗一个序号，此时客户端进入SYN-SEND状态。
* B接收到连接报文后，向A发送确认信息，此时SYN = 1 ACK = 1 序号seq = y  确认号ack = x+1，这个报文段也不能携带数据，但是要消耗一个序号，然后服务端进入SYN-REVD状态。
* 客户端收到确认信息后，还要给服务端一个确认，确认号ack = y+1。TCP规定ACK报文段可以携带数据，不携带数据就不消耗序号，这种情况下下个数据报文段的序号还是x+1，然后客户端进入ESTABLISHED状态，B收到确认后也进入ESTABLISHED状态
为什么A还要发送一个确认信息呢？主要是为了防止已经失效的链接请求报文段突然又传到了服务端。例如，A像B发了个连接请求报文，但是滞留在了网络某处，没有及时的传到B，A肯定要重传，重传之后建立了连接。但是后来这个滞留的报文又传到了B。如果没有三次握手，B肯定认为A要建立连接，然后就回复确认，但是A不这么认为，A已经重传了，这个算是旧的，没用的连接请求，A不会理会，那B又不知道，还一直傻傻的等待A给他传数据，这样就导致B端部分资源浪费
## TCP的连接释放
![四次挥手][2]
数据通讯结束后，双方都要释放连接。
* 客户端A首先B发送释放连接报文，并停止再发送数据主动关闭tcp连接，发送的信息如图，其中seq是上次发送数据的最后一个序号+1，A进入FIN=WAIT-1状态，TCP规定FIN不能携带数据，但是要消耗一个序号
* B收到消息后，发送确认报文，信息如图，其中seq是上次接收的数据的序号+1，然后B进入CLOSE-WAIT状态。TCP服务器进程应该通知高层应用进程，因为从A到B的连接就释放掉了，此时TCP处于半关闭状态。A已经没有数据传给B了，但是B还可以传数据给A
* A接到确认后，就进入FIN=WAIT-2状态，等待B发送连接释放报文，若B没有数据传送了，应用程序就通知释放连接，B发送最后的释放报文，B进入最后确认状态
* A接收到最后释放报文后，还要回复确认然后进入时间等待状态，此时连接依然没有释放，必须经过时间等待计时器设置的时间2MSL后，A才能进入close状态。时间MSL叫做最长报文段寿命，默认2分钟，但是可以根据实际修改，现代网络，2分钟有点长，可以设短一点
#### A必须等待2MSL的原因
* 为了保证A最后发送的确认信息能到达B。因为最后的报文可能丢失，如果直接关闭连接，那B没有收到最后确认，就无法关闭。在等待2MSL的时候，如果最后确认报文丢失，那么B会重传最后释放报文，然后A再回复最后确认，这样就保证了双端都能正常关闭
* 防止已失效的连接出现在新连接中，当A发送完最后一个ACK等待2MSL过程中，可以保证前面发送的数据都会在网络中消失（正常发送的会到B端，延时的会到B端或者直接被路由丢掉），这样在新的连接中就不会有旧连接的数据
除了时间等待计时器外，TCP还有个保活计时器。设想这么个场景，客户端连接到服务端后 ，突然发生故障了，无法与服务端通信了，显然服务端以后再也收不到客户端的信息了。当这个时候，我们不能让服务器就这么干等下去，总要做点什么，这就是保活计时器的作用。服务器没收到客户端的消息，都会重置保活计时器时间，一般为2个小时，当超出时间没有收到信息后，服务端就发送一个探测报文，以后每隔75分钟发一个，如果一连发10次都没有响应，则断开连接



  [1]: http://ofy9dm2ii.bkt.clouddn.com/image/article/tcp_connect.png
  [2]: http://ofy9dm2ii.bkt.clouddn.com/image/article/tcp_clos.png
